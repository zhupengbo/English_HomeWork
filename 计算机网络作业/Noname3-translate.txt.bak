



HTTPAUTH                                                     A. Melnikov
Internet-Draft                                                 Isode Ltd
Intended status: Experimental                           December 5, 2015
Expires: June 7, 2016


    Salted Challenge Response (SCRAM) HTTP Authentication Mechanism    SCRAM――http认证机制
                 draft-ietf-httpauth-scram-auth-14.txt

Abstract							    概述

   This specification describes a family of HTTP authentication     这篇文档详细介绍SCRAM认证机制，它提供了一种比传输层的纯文
   mechanisms called the Salted Challenge Response Authentication   本密码保护机制更加健壮的认证机制，同时避免了早期TLS响应授
   Mechanism (SCRAM), which provides a more robust authentication   权机制的部署障碍。
   mechanism than a plaintext password protected by Transport Layer
   Security (TLS) and avoids the deployment obstacles presented by
   earlier TLS-protected challenge response authentication mechanisms.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on June 7, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as



Melnikov                  Expires June 7, 2016                  [Page 1]

Internet-Draft                 HTTP SCRAM                  December 2015


   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  Conventions Used in This Document . . . . . . . . . . . . . .   3
   2.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . . .   4
   3.  SCRAM Algorithm Overview  . . . . . . . . . . . . . . . . . .   5
   4.  SCRAM Mechanism Names . . . . . . . . . . . . . . . . . . . .   6
   5.  SCRAM Authentication Exchange . . . . . . . . . . . . . . . .   7
   5.1.  One round trip reauthentication . . . . . . . . . . . . . .  10
   6.  Use of Authentication-Info header field with SCRAM  . . . . .  12
   7.  Formal Syntax . . . . . . . . . . . . . . . . . . . . . . . .  12
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  15
   10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  15
   11. Design Motivations  . . . . . . . . . . . . . . . . . . . . .  15
   12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  16
   12.1.  Normative References . . . . . . . . . . . . . . . . . . .  16
   12.2.  Informative References . . . . . . . . . . . . . . . . . .  17
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  18

1.  Introduction							 1.引言

   The authentication mechanism most widely deployed and used by          TLS的纯文本密码形式是应用最为广泛的认证机制，并且正在
   Internet application protocols is the transmission of clear-text       被网络应用层协议所使用。这种通过TLS来保证质询-响应的
   passwords over a channel protected by Transport Layer Security (TLS).  认证机制仍旧有许多可取的地方。不幸的是，目前HTTP摘要 
   There are some significant security concerns with that mechanism,	  认证仅仅在一些特定的环境下可以使用，并不能广泛推广。
   which could be addressed by the use of a challenge response
   authentication mechanism protected by TLS.  Unfortunately, the HTTP
   Digest challenge response mechanism presently on the standards track
   failed widespread deployment, and have had success only in limited
   use.

   This specification describes a family of authentication mechanisms	 本文介绍一类被称为伪装质询-响应认证机制（SCRAM），
   called the Salted Challenge Response Authentication Mechanism (SCRAM) 在部署质询-响应机制时需要满足的必要条件方面，它比以前的	
   which addresses the requirements necessary to deploy a challenge-     方式（详情见[RFC5802]）更加容易处理。另外，它还可以处理
   response mechanism more widely than past attempts (see [RFC5802]).    HTTP摘要认证的一些问题，比如为了防御第三方攻击，需要在
   In particular, it addresses some of the issues identified with HTTP   认证过程中将实施和保护复杂化。
   Digest [RFC6331], such as complexity of implementing and protection
   of the whole authentication exchange in order to protect from certain
   man-in-the-middle attacks.

   HTTP SCRAM is adoptation of [RFC5802] for use in HTTP.  (SCRAM data	 HTTP SCRAM被收录在[RFC5802]，用于HTTP使用标准。（SCRAM 
   exchanged is identical to what is defined in [RFC5802].)  It also	 数据交换同样被定义在[RFC5802]）它也被添加在1往返重新认证
   adds 1 round trip reauthentication mode.				 模式。




Melnikov                  Expires June 7, 2016                  [Page 2]

Internet-Draft                 HTTP SCRAM                  December 2015


   HTTP SCRAM provides the following protocol features:			 HTTP SCRAM有以下特征：

   o  The authentication information stored in the authentication	 o 存储在认证数据库中的认证信息不足以让黑客伪装成客户端
      database is not sufficient by itself (without a dictionary attack) （在没有字典攻击的情况下）。即使数据库泄露，这些被伪装
      to impersonate the client.  The information is salted to prevent a  过的数据信息也能够防止预先存储字典攻击。
      pre-stored dictionary attack if the database is stolen.

   o  The server does not gain the ability to impersonate the client to  o 服务端不能模拟其他服务端的客户端（除非被其他服务器授权）
      other servers (with an exception for server-authorized proxies).

   o  The mechanism permits the use of a server-authorized proxy without o 该机制允许在没有请求后端服务器超级用户权限的情况下，使用
      requiring that proxy to have super-user rights with the back-end    服务器认证代理。
      server.

   o  Mutual authentication is supported, but only the client is named   o 支持相互认证，但是只有客户端被命名（服务端没有名字）。
      (i.e., the server has no name).

2.  Conventions Used in This Document					2.本文中的约定

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",    文档中"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
   document are to be interpreted as described in [RFC2119].               相关解释参考[RFC2119]。

   Formal syntax is defined by [RFC5234] including the core rules         正式语法规则参考[RFC5234]，还有一些核心规则参考[RFC5234]附录B。
   defined in Appendix B of [RFC5234].

   Example lines prefaced by "C:" are sent by the client and ones	  样例行以“C:”开头的是客户端发送的，服务器端发送的以”S:“开头，
   prefaced by "S:" by the server.  If a single "C:" or "S:" label        如果一个单一的”C:“或者”S:“被用于多行，则他们只是用于分割多行，
   applies to multiple lines, then the line breaks between those lines    使结构清晰，不是实际语法交换的一部分。
   are for editorial clarity only, and are not part of the actual
   protocol exchange.

2.1.  Terminology							2.1 术语

   This document uses several terms defined in [RFC4949] ("Internet       本文使用的一些术语定义在[RFC4949]（网络安全术语表）中，
   Security Glossary") including the following: authentication,           包括：认证，认证交换，认证信息，暴力，质询-响应，哈希
   authentication exchange, authentication information, brute force,      加密函数，字典攻击，窃听，散列结果，哈希，中间人，随机数
   challenge-response, cryptographic hash function, dictionary attack,    单向加密函数，密码，重放攻击和伪装。读者如果不熟悉这些
   eavesdropping, hash result, keyed hash, man-in-the-middle, nonce,	  术语可参考该术语表。
   one-way encryption function, password, replay attack and salt.
   Readers not familiar with these terms should use that glossary as a
   reference.

   Some clarifications and additional definitions follow:		 一些澄清和额外定义：  

   o  Authentication information: Information used to verify an identity o 认证信息：用于验证SCRAM客户端的信息。该认证信息包括伪装
      claimed by a SCRAM client.  The authentication information for a     ，迭代计算，”StoredKey“和”ServerKey“（定义见算法概述）。	
      SCRAM identity consists of salt, iteration count, the "StoredKey"    被所有支持加密的哈希算法使用。



Melnikov                  Expires June 7, 2016                  [Page 3]

Internet-Draft                 HTTP SCRAM                  December 2015


      and "ServerKey" (as defined in the algorithm overview) for each
      supported cryptographic hash function.

   o  Authentication database: The database used to look up the         o 认证数据库：被用于查找认证信息的数据库，紧密联系于身份
      authentication information associated with a particular identity.    认证。对于应用层协议，LDAPv3（见[RFC4510]）常被用做认证
      For application protocols, LDAPv3 (see [RFC4510]) is frequently      数据库。对于低层次协议如PPP或者802.11x,RADIUS [RFC2865]
      used as the authentication database.  For lower-layer protocols      更加常用。
      such as PPP or 802.11x, the use of RADIUS [RFC2865] is more
      common.

   o  Base64: An encoding mechanism defined in Section 4 of [RFC4648]   o Base64：一种被定义在[RFC4648]第四节的编码机制，它将字节码
      which converts an octet string input to a textual output string      的字符串输入转换为更易于人们理解的文本字符串输出。base64被用于SCRAM
      which can be easily displayed to a human.  The use of base64 in	   中没有空格的规范文本中。
      SCRAM is restricted to the canonical form with no whitespace.

   o  Octet: An 8-bit byte.						o Octet:八位的字节。

   o  Octet string: A sequence of 8-bit bytes.                          o Octet string:八位字节的序列。
 
   o  Salt: A random octet string that is combined with a password      o Salt:将一个随机的八位字符串糅合在密码中，再将其应用
      before applying a one-way encryption function.  This value is used   在单向加密函数中。该值的作用是保护被存储在认证数据
      to protect passwords that are stored in an authentication            库中的密码。
      database.

2.2.  Notation							       2.2. 符号说明

   The pseudocode description of the algorithm uses the following         算法的伪代码描述使用了以下的符号：
   notations:

   o  ":=": The variable on the left hand side represents the octet      o ":=":等号左边的变量表示右边表达式结果的八位字符串形式。
      string resulting from the expression on the right hand side.

   o  "+": Octet string concatenation.                                   o "+":字符串的连接。

   o  "[ ]": A portion of an expression enclosed in "[" and "]" may not  o "[ ]":"["和"]"中间的部分在某些情况下可能不被包含在结果中。
      be included in the result under some circumstances.  See the	     关于这些情况，参见相关文本描述。
      associated text for a description of those circumstances.

   o  Normalize(str): Apply the Preparation and Enforcement steps	 o 规范化(str):应用OpaqueString概要文件（见[RFC7613]）中
      according to the OpaqueString profile (see [RFC7613]) to a UTF-8     准备和实施步骤规范化为utf-8编码的字符串。由此产生的
      [RFC3629] encoded "str".  The resulting string is also in UTF-8.	   字符串也是utf-8。注意该操作要么实现OpaqueString概要文
      Note that implementations MUST either implement OpaqueString	   件（[RFC7613]），要么不允许在”str“中使用非US-ASCII 
      profile operations from [RFC7613], or disallow use of non US-ASCII   Unicode代码点。后者的具体情况符合(RFC7613)。
      Unicode codepoints in "str".  The latter is a particular case of
      compliance with [RFC7613].

   o  HMAC(key, str): Apply the HMAC keyed hash algorithm (defined in    o HMAC(key, str):应用了HMAC的散列算法(定义见
     [RFC2104]) using the octet string represented by "key" as the key      [RFC2104])使用八位字节字符串为代表的“key”作为key值，
									     并且这”str“作为输入字符串。结果的大小就是使用的哈希函数
									    的结果大小。例如，SHA-256是32个8位字节，SHA-1是20个（见[RFC6234]）


Melnikov                  Expires June 7, 2016                  [Page 4]

Internet-Draft                 HTTP SCRAM                  December 2015


      and the octet string "str" as the input string.  The size of the
      result is the hash result size for the hash function in use.  For
      example, it is 32 octets for SHA-256 and 20 octets for SHA-1 (see
      [RFC6234]).

   o  H(str): Apply the cryptographic hash function to the octet string  o H(str):将加密哈希函数应用于8位字节的字符串”str“，产生
      "str", producing an octet string as a result.  The size of the        一个8位字节的字符串结果。结果的大小取决于选用的哈希函数。
      result depends on the hash result size for the hash function in
      use.

   o  XOR: Apply the exclusive-or operation to combine the octet string  o XOR: 将操作符的左右两边进行异或操作。两个输入和输出的长度
      on the left of this operator with the octet string on the right of    相同。
      this operator.  The length of the output and each of the two
      inputs will be the same for this use.

   o  Hi(str, salt, i):							 o Hi(str, salt, i):


      U1   := HMAC(str, salt + INT(1))					    U1   := HMAC(str, salt + INT(1))
      U2   := HMAC(str, U1)                                                 U2   := HMAC(str, U1)
      ...								    ...
      Ui-1 := HMAC(str, Ui-2)						    Ui-1 := HMAC(str, Ui-2)
      Ui   := HMAC(str, Ui-1)						    Ui   := HMAC(str, Ui-1)

      Hi := U1 XOR U2 XOR ... XOR Ui					    Hi := U1 XOR U2 XOR ... XOR Ui


      where "i" is the iteration count, "+" is the string concatenation     其中”i“为迭代计数器，”+“是字符串连接操作，INT（g）
      operator and INT(g) is a four-octet encoding of the integer g,	    是整型g的four-octet编码，最重要的八位字节。
      most significant octet first.

      Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the PRF and     本质上讲，Hi()是 PBKDF2 [RFC2898]使用 HMAC()作为
      with dkLen == output length of HMAC() == output length of H().	    PRF并且dkLen == HMAC()输出长度==H()输出长度。


3.  SCRAM Algorithm Overview						  3. SCRAM算法预览

   The following is a description of a full HTTP SCRAM authentication       下面是一个完整的HTTP SCRAM认证交换的描述。这一节
   exchange.  Note that this section omits some details, such as client     省略了一些细节，如客户端和服务端随机数。更多细节参见章节
   and server nonces.  See Section 5 for more details.			    章节5。

   To begin with, the SCRAM client is in possession of a username and       作为开始，SCRAM客户端拥有用户名和密码（或者ClientKey/ServerKey,
   password (*) (or a ClientKey/ServerKey, or SaltedPassword).  It sends    ，或伪装过的密码）。发送用户名到服务端，获取相应的
   the username to the server, which retrieves the corresponding            认证信息，比如干扰码，StoredKey, ServerKey和迭代计数i。
   authentication information, i.e. a salt, StoredKey, ServerKey and the    （服务端的实现有可能选择使用相同的迭代技术）服务端发送
   iteration count i.  (Note that a server implementation may choose to     干扰码和迭代计数到客户端，客户端计算下面的值并且发送
   use the same iteration count for all accounts.)  The server sends the    客户端证明给服务端：
   salt and the iteration count to the client, which then computes the
   following values and sends a ClientProof to the server:



Melnikov                  Expires June 7, 2016                  [Page 5]

Internet-Draft                 HTTP SCRAM                  December 2015


   (*) - Note that both the username and the password MUST be encoded in    (*) - 注意：用户名和密码必须是UTF-8 [RFC3629]编码。
   UTF-8 [RFC3629].							     			

   Informative Note: Implementors are encouraged to create test cases        有用的笔记：建议实现者使用非ASCLL代码点形式的用户名
   that use both username passwords with non-ASCII codepoints.  In	     和密码。特别的，对于测试"Unicode Normalization Form C" 
   particular, it is useful to test codepoints whose "Unicode		     和"Unicode Normalization Form KC"的不同是非常有用的。
   Normalization Form C" and "Unicode Normalization Form KC" are             该类示例还包括分数的一半(U+00BD)和比较偏的词(U+00B4)。
   different.  Some examples of such codepoints include Vulgar Fraction
   One Half (U+00BD) and Acute Accent (U+00B4).


      SaltedPassword  := Hi(Normalize(password), salt, i)                    
      ClientKey       := HMAC(SaltedPassword, "Client Key")
      StoredKey       := H(ClientKey)
      AuthMessage     := client-first-message-bare + "," +
                         server-first-message + "," +
                         client-final-message-without-proof
      ClientSignature := HMAC(StoredKey, AuthMessage)
      ClientProof     := ClientKey XOR ClientSignature
      ServerKey       := HMAC(SaltedPassword, "Server Key")
      ServerSignature := HMAC(ServerKey, AuthMessage)


   The server authenticates the client by computing the ClientSignature,     服务端根据计算客户端签名认证客户端，异或ClientProof
   exclusive-ORing that with the ClientProof to recover the ClientKey	     去恢复ClientKey，应用哈希函数验证ClientKey的正确性，
   and verifying the correctness of the ClientKey by applying the hash       然后将结果与StoredKey做比较。如果ClientKey是正确的，
   function and comparing the result to the StoredKey.  If the ClientKey     证明该客户端可以访问用户密码。
   is correct, this proves that the client has access to the user's
   password.

   Similarly, the client authenticates the server by computing the           同样，客户端根据计算服务端的签名并比较该值来认证服务端。
   ServerSignature and comparing it to the value sent by the server.  If     如果两个值相等，证明该服务端可以访问用户的ServerKey。
   the two are equal, it proves that the server had access to the user's
   ServerKey.

   For initial authentication the AuthMessage is computed by                 对于首次认证，认证消息根据认证交换的”data“属性解码
   concatenating decoded "data" attribute values from the authentication     计算获得。消息格式定义在[RFC5802]。
   exchange.  The format of these messages is defined in [RFC5802].

4.  SCRAM Mechanism Names						   4.  SCRAM机制名称

   A SCRAM mechanism name (authentication scheme) is a string "SCRAM-"       一个SCRAM机制名称（认证机制）是一个字符串"SCRAM-"，
   followed by the uppercased name of the underlying hash function taken     后面紧跟注册于IANA的”哈希文本名称“的大写名称。
   from the IANA "Hash Function Textual Names" registry (see                 （见http://www.iana.org）。
   http://www.iana.org) .

   For interoperability, all HTTP clients and servers supporting SCRAM       为了互操作性，所有支持SCRAM的HTTP客户端和服务端必须
   MUST implement the SCRAM-SHA-256 authentication mechanism, i.e. an        实现SCRAM-SHA-256认证机制。例如，一个SCRAM的认证机制



Melnikov                  Expires June 7, 2016                  [Page 6]

Internet-Draft                 HTTP SCRAM                  December 2015


   authentication mechanism from the SCRAM family that uses the SHA-256      使用SHA-256哈希函数，定义见[RFC7677]。
   hash function as defined in [RFC7677].

5.  SCRAM Authentication Exchange					   5.  SCRAM 认证交换

   HTTP SCRAM is a HTTP Authentication mechanism whose client response       HTTP SCRAM是一种客户端相应，服务端质询的认证机制
   (<credentials-scram>) and server challenge (<challenge-scram>)	     它的消息是基于文本的，包含一个或者多个被逗号分隔的属性对。
   messages are text-based messages containing one or more attribute-        这些消息和属性描述如下，定义见section 7。
   value pairs separated by commas.  The messages and their attributes       
   are described below and defined in Section 7.


       challenge-scram   = scram-name [1*SP 1#auth-param]
             ; Complies with <challenge> ABNF from RFC 7235.                  符合RFC 7235 <challenge> ABNF    
             ; Included in the WWW-Authenticate header field.                 包含在WWW-Authenticate头部。

       credentials-scram = scram-name [1*SP 1#auth-param]
             ; Complies with <credentials> from RFC 7235.                     符合RFC 7235 <credentials>
             ; Included in the Authorization header field.                    包含在认证头部

       scram-name = "SCRAM-SHA-256" / "SCRAM-SHA-1" / other-scram-name
             ; SCRAM-SHA-256 and SCRAM-SHA-1 are registered by this RFC.       SCRAM-SHA-256和SCRAM-SHA-1注册在RFC
             ;
             ; SCRAM-SHA-1 is registered for database compatibility            SCRAM-SHA-1用于数据库兼容性，使用RFC 5802的实现 
             ; with implementations of RFC 5802 (such as IMAP or XMPP          （如IMAP或XMPP 服务），但不推荐使用。
             ; servers), but it is not recommended for new deployments.

       other-scram-name = "SCRAM-" hash-name
             ; hash-name is a capitalized form of names from IANA              哈希名称是注册于IANA的”哈希函数文本名称“的大写，
             ; "Hash Function Textual Names" registry.			       额外的SCRAM名称必须都被注册于IANA 的"SASL mechanisms"
             ; Additional SCRAM names must be registered in both               和"authentication scheme"。
             ; the IANA "SASL mechanisms" registry
             ; and the IANA "authentication scheme" registry.


   This is a simple example of a SCRAM-SHA-256 authentication exchange         一个简单的SCRAM-SHA-256认证交换示例如下（不支持信道绑定，
   (no support for channel bindings, as this feature is not currently         该功能目前不被HTTP支持）。名户名”user“和密码”pencil“。
   supported by HTTP).  Username 'user' and password 'pencil' are used.       长线被加粗是为了方便阅读。
   Note that long lines are folded for readability. 












Melnikov                  Expires June 7, 2016                  [Page 7]

Internet-Draft                 HTTP SCRAM                  December 2015


   C: GET /resource HTTP/1.1
   C: Host: server.example.com
   C: [...]

   S: HTTP/1.1 401 Unauthorized
   S: WWW-Authenticate: Digest realm="realm1@example.com",
          Digest realm="realm2@example.com",
          Digest realm="realm3@example.com",
          SCRAM-SHA-256 realm="realm3@example.com",
          SCRAM-SHA-256 realm="testrealm@example.com"
   S: [...]

   C: GET /resource HTTP/1.1
   C: Host: server.example.com
   C: Authorization: SCRAM-SHA-256 realm="testrealm@example.com",
          data=biwsbj11c2VyLHI9ck9wck5HZndFYmVSV2diTkVrcU8K
   C: [...]

   S: HTTP/1.1 401 Unauthorized
   S: WWW-Authenticate: SCRAM-SHA-256
           sid=AAAABBBBCCCCDDDD,
           data=cj1yT3ByTkdmd0ViZVJXZ2JORWtxTyVodllEcFdVYTJSYVRDQWZ1eEZJbGo
             paE5sRixzPVcyMlphSjBTTlk3c29Fc1VFamI2Z1E9PSxpPTQwOTYK
   S: [...]

   C: GET /resource HTTP/1.1
   C: Host: server.example.com
   C: Authorization: SCRAM-SHA-256 sid=AAAABBBBCCCCDDDD,
          data=Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU8laHZZRHBXVWEyUmFUQ0FmdXhG
               SWxqKWhObEYscD1kSHpiWmFwV0lrNGpVaE4rVXRlOXl0YWc5empmTUhnc3FtbWl6
               N0FuZFZRPQo=
   C: [...]

   S: HTTP/1.1 200 Ok
   S: Authentication-Info: sid=AAAABBBBCCCCDDDD,
          data=dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5NUc0PQo=
   S: [...Other header fields and resource body...]


   In the above example the first client request contains data attribute        上述示例中，第一个客户端请求数据包含的属性被
   which base64 decodes as follows: "n,,n=user,r=rOprNGfwEbeRWgbNEkqO"          被base64解码如下："n,,n=user,r=rOprNGfwEbeRWgbNEkqO"
   (with no quotes).  Server then responds with data attribute which            服务端响应数据属性如下："r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxF
   base64 decodes as follows: "r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxF         Ilj)hNlF,s=W22ZaJ0SNY7soEsUEjb6gQ==,i=4096"。下一个
   Ilj)hNlF,s=W22ZaJ0SNY7soEsUEjb6gQ==,i=4096".  The next client request        客户端请求数据包含的属性被base64解码如下：
   contains data attribute which base64 decodes as follows: "c=biws,r=rO         "c=biws,r=rO
   prNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF,p=dHzbZapWIk4jUhN+Ute9y         prNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF,p=dHzbZapWIk4jUhN+Ute9y
   tag9zjfMHgsqmmiz7AndVQ=".  The final server response contains a data          tag9zjfMHgsqmmiz7AndVQ="。服务端响应数据：
   attribute which base64 decodes as follows:



Melnikov                  Expires June 7, 2016                  [Page 8]

Internet-Draft                 HTTP SCRAM                  December 2015


   "v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4=".				"v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4="。

   Note that in the example above the client can also initiate SCRAM            注意上述示例中，客户端也可以初始化SCRAM认证，而不必
   authentication without first being prompted by the server.                   等待服务端提示。

   Initial "SCRAM-SHA-256" authentication starts with sending the               最初的"SCRAM-SHA-256"认证以发送"Authorization"请求头
   "Authorization" request header field defined by HTTP/1.1, Part 7             作为开始，定义见HTTP/1.1，Part 7 [RFC7235]包括了
   [RFC7235] containing "SCRAM-SHA-256" authentication scheme and the           "SCRAM-SHA-256"认证机制和一下属性：
   following attributes:

   o  A "realm" attribute MAY be included to indicate the scope of
      protection in the manner described in HTTP/1.1, Part 7 [RFC7235].
      As specified in [RFC7235], the "realm" attribute MUST NOT appear
      more than once.  The realm attribute only appears in the first
      SCRAM message to the server and in the first SCRAM response from
      the server.

   o  The client also includes the data attribute that contains base64
      encoded "client-first-message" [RFC5802] containing:

      *  a header consisting of a flag indicating whether channel
         binding is supported-but-not-used, not supported, or used .
         Note that this version of SCRAM doesn't support HTTP channel
         bindings, so this header always starts with "n"; otherwise the
         message is invalid and authentication MUST fail.

      *  SCRAM username and a random, unique nonce attributes.

   In HTTP response, the server sends WWW-Authenticate header field
   containing: a unique session identifier (the "sid" attribute) plus
   the "data" attribute containing base64-encoded "server-first-message"
   [RFC5802].  The "server-first-message" contains the user's iteration
   count i, the user's salt, and the nonce with a concatenation of the
   client-specified one (taken from the "client-first-message") with a
   freshly generated server nonce.

   The client then responds with another HTTP request with the
   Authorization header field, which includes the "sid" attribute
   received in the previous server response, together with the "data"
   attribute containing base64-encoded "client-final-message" data.  The
   latter has the same nonce as in "server-first-message" and a
   ClientProof computed using the selected hash function (e.g.  SHA-256)
   as explained earlier.

   The server verifies the nonce and the proof, and, finally, it
   responds with a 200 HTTP response with the Authentication-Info header
   field [RFC7615] containing the "sid" attribute (as received from the
   client) and the "data" attribute containing base64-encoded "server-



Melnikov                  Expires June 7, 2016                  [Page 9]

Internet-Draft                 HTTP SCRAM                  December 2015


   final-message", concluding the authentication exchange.

   The client then authenticates the server by computing the
   ServerSignature and comparing it to the value sent by the server.  If
   the two are different, the client MUST consider the authentication
   exchange to be unsuccessful and it might have to drop the connection.

5.1.  One round trip reauthentication

   If the server supports SCRAM reauthentication, the server sends in
   its initial HTTP response a WWW-Authenticate header field containing:
   the "realm" attribute (as defined earlier), the "sr" attribute that
   contains the server part of the "r" attribute (see s-nonce in
   [RFC5802]) and optional "ttl" attribute (which contains the "sr"
   value validity in seconds).

   If the client has authenticated to the same realm before (i.e. it
   remembers "i" and "s" attributes for the user from earlier
   authentication exchanges with the server), it can respond to that
   with "client-final-message".  When constructing the "client-final-
   message" the client constructs the c-nonce part of the "r" attribute
   as on initial authentication and the s-nonce part as follows: s-nonce
   is a concatenation of nonce-count and the "sr" attribute (in that
   order).  The nonce-count is a positive integer that that is equal to
   the user's "i" attribute on first reauthentication and is incremented
   by 1 on each successful re-authentication.

      The purpose of the nonce-count is to allow the server to detect
      request replays by maintaining its own copy of this count - if the
      same nonce-count value is seen twice, then the request is a
      replay.

   If the server considers the s-nonce part of the nonce attribute (the
   "r" attribute) to be still valid (i.e. the nonce-count part is as
   expected (see above) and the "sr" part is still fresh), it will
   provide access to the requested resource (assuming the client hash
   verifies correctly, of course).  However if the server considers that
   the server part of the nonce is stale (for example if the "sr" value
   is used after the "ttl" seconds), the server returns "401
   Unauthorized" containing the SCRAM mechanism name with the following
   attributes: a new "sr", "stale=true" and an optional "ttl".  The
   "stale" attribute signals to the client that there is no need to ask
   user for the password.

      Formally, the "stale" attribute is defined as follows: A flag,
      indicating that the previous request from the client was rejected
      because the nonce value was stale.  If stale is TRUE (case-
      insensitive), the client may wish to simply retry the request with



Melnikov                  Expires June 7, 2016                 [Page 10]

Internet-Draft                 HTTP SCRAM                  December 2015


      a new encrypted response, without reprompting the user for a new
      username and password.  The server should only set stale to TRUE
      if it receives a request for which the nonce is invalid but with a
      valid digest for that nonce (indicating that the client knows the
      correct username/password).  If stale is FALSE, or anything other
      than TRUE, or the stale directive is not present, the username
      and/or password are invalid, and new values must be obtained.

   When constructing AuthMessage Section 3 to be used for calculating
   client and server proofs, "client-first-message-bare" and "server-
   first-message" are reconstructed from data known to the client and
   the server.

   Reauthentication can look like this:





































Melnikov                  Expires June 7, 2016                 [Page 11]

Internet-Draft                 HTTP SCRAM                  December 2015


   C: GET /resource HTTP/1.1
   C: Host: server.example.com
   C: [...]

   S: HTTP/1.1 401 Unauthorized
   S: WWW-Authenticate: Digest realm="realm1@example.com",
          Digest realm="realm2@example.com",
          Digest realm="realm3@example.com",
          SCRAM-SHA-256 realm="realm3@example.com",
          SCRAM-SHA-256 realm="testrealm@example.com", sr=%hvYDpWUa2RaTCAfuxFIlj)hNlF
          SCRAM-SHA-256 realm="testrealm2@example.com", sr=AAABBBCCCDDD, ttl=120
   S: [...]

   [Client authenticates as usual to realm "testrealm@example.com"]

   [Some time later client decides to reauthenticate.
    It will use the cached "i" (4096) and "s" (W22ZaJ0SNY7soEsUEjb6gQ==)
    from earlier exchanges. It will use the nonce-value of 4096 together
    with the server advertised "sr" value as the server part of the "r".]

   C: GET /resource HTTP/1.1
   C: Host: server.example.com
   C: Authorization: SCRAM-SHA-256 realm="testrealm@example.com",
          data=Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU80MDk2JWh2WURwV1VhMlJhVENB
               ZnV4RklsailoTmxGLHA9ZEh6YlphcFdJazRqVWhOK1V0ZTl5dGFnOXpqZk1IZ3Nx
               bW1pejdBbmRWUT0K

   C: [...]

   S: HTTP/1.1 200 Ok
   S: Authentication-Info: sid=AAAABBBBCCCCDDDD,
          data=dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5NUc0PQo=
   S: [...Other header fields and resource body...]


6.  Use of Authentication-Info header field with SCRAM

   When used with SCRAM, the Authentication-Info header field is allowed
   in the trailer of an HTTP message transferred via chunked transfer-
   coding.

7.  Formal Syntax

   The following syntax specification uses the Augmented Backus-Naur
   Form (ABNF) notation as specified in [RFC5234].






Melnikov                  Expires June 7, 2016                 [Page 12]

Internet-Draft                 HTTP SCRAM                  December 2015


      ALPHA = <as defined in RFC 5234 appendix B.1>
      DIGIT = <as defined in RFC 5234 appendix B.1>

      base64-char     = ALPHA / DIGIT / "/" / "+"

      base64-4        = 4base64-char

      base64-3        = 3base64-char "="

      base64-2        = 2base64-char "=="

      base64          = *base64-4 [base64-3 / base64-2]

      sr              = "sr=" s-nonce
                        ;; s-nonce is defined in RFC 5802.

      data            = "data=" base64
                        ;; The data attribute value is base64 encoded
                        ;; SCRAM challenge or response defined in
                        ;; RFC 5802.

      ttl             = "ttl" = 1*DIGIT
                        ;; "sr" value validity in seconds.
                        ;; No leading 0s.

      reauth-s-nonce  = nonce-count s-nonce

      nonce-count     = posit-number
                        ;; posit-number is defined in RFC 5802.
                        ;; The initial value is taken from the "i"
                        ;; attribute for the user and is incremented
                        ;; by 1 on each successful re-authentication.

      sid             = "sid=" token
                        ;; See token definition in RFC 7235.

      stale           = "stale=" ( "true" / "false" )

      realm           = "realm=" <as defined in RFC 7235>


8.  Security Considerations

   If the authentication exchange is performed without a strong session
   encryption (such as TLS with data confidentiality), then a passive
   eavesdropper can gain sufficient information to mount an offline
   dictionary or brute-force attack which can be used to recover the
   user's password.  The amount of time necessary for this attack



Melnikov                  Expires June 7, 2016                 [Page 13]

Internet-Draft                 HTTP SCRAM                  December 2015


   depends on the cryptographic hash function selected, the strength of
   the password and the iteration count supplied by the server.  SCRAM
   allows the server/server administrator to increase the iteration
   count over time in order to slow down the above attacks.  (Note that
   a server that is only in posession of "StoredKey" and "ServerKey"
   can't automatic increase the iteration count upon successful
   authentication.  Such increase would require resetting user's
   password.)  An external security layer with strong encryption will
   prevent these attack.

   If the authentication information is stolen from the authentication
   database, then an offline dictionary or brute-force attack can be
   used to recover the user's password.  The use of salt mitigates this
   attack somewhat by requiring a separate attack on each password.
   Authentication mechanisms which protect against this attack are
   available (e.g., the EKE class of mechanisms).  RFC 2945 [RFC2945] is
   an example of such technology.

   If an attacker obtains the authentication information from the
   authentication repository and either eavesdrops on one authentication
   exchange or impersonates a server, the attacker gains the ability to
   impersonate that user to all servers providing SCRAM access using the
   same hash function, password, iteration count and salt.  For this
   reason, it is important to use randomly-generated salt values.

   SCRAM does not negotiate a hash function to use.  Hash function
   negotiation is left to the HTTP authentication mechanism negotiation.
   It is important that clients be able to sort a locally available list
   of mechanisms by preference so that the client may pick the most
   preferred of a server's advertised mechanism list.  This preference
   order is not specified here as it is a local matter.  The preference
   order should include objective and subjective notions of mechanism
   cryptographic strength (e.g., SCRAM with a successor to SHA-1 may be
   preferred over SCRAM with SHA-1).

   A hostile server can perform a computational denial-of-service attack
   on clients by sending a big iteration count value.  In order to
   defend against that, a client implementation can pick a maximum
   iteration count that it is willing to use, and that it rejects any
   values that exceed that threshold (in such cases the client, of
   course, has to fail the authentication).

   See [RFC4086] for more information about generating randomness.

   This document recommends use of SCRAM with SHA-256 hash.  SCRAM-SHA-1
   is registered for database compatibility with implementations of RFC
   5802 (such as IMAP or XMPP servers) which want to also expose HTTP
   access to a related service, but it is not recommended for new



Melnikov                  Expires June 7, 2016                 [Page 14]

Internet-Draft                 HTTP SCRAM                  December 2015


   deployments.

9.  IANA Considerations

   New mechanisms in the SCRAM- family are registered according to the
   IANA procedure specified in [RFC5802].

   Note to future SCRAM- mechanism designers: each new SCRAM- HTTP
   authentication mechanism MUST be explicitly registered with IANA and
   MUST comply with SCRAM- mechanism naming convention defined in
   Section 4 of this document.

   IANA is requested to add the following entry to the Authentication
   Scheme Registry defined in HTTP/1.1, Part 7 [RFC7235]:


   Authentication Scheme Name: SCRAM-SHA-256
   Pointer to specification text: [[ this document ]]
   Notes (optional): (none)



   Authentication Scheme Name: SCRAM-SHA-1
   Pointer to specification text: [[ this document ]]
   Notes (optional): (none)


10.  Acknowledgements

   This document benefited from discussions on the HTTPAuth, SASL and
   Kitten WG mailing lists.  The authors would like to specially thank
   co-authors of [RFC5802] from which lots of text was copied.

   Thank you to Martin Thomson for the idea of adding "ttl" attribute.

   Thank you to Julian F.  Reschke for corrections regarding use of
   Authentication-Info header field.

   Special thank you to Tony Hansen for doing an early implementation
   and providing extensive comments on the draft.

11.  Design Motivations

   The following design goals shaped this document.  Note that some of
   the goals have changed since the initial version of the document.

   o  The HTTP authentication mechanism has all modern features: support
      for internationalized usernames and passwords, support for channel



Melnikov                  Expires June 7, 2016                 [Page 15]

Internet-Draft                 HTTP SCRAM                  December 2015


      bindings.

   o  The protocol supports mutual authentication.

   o  The authentication information stored in the authentication
      database is not sufficient by itself to impersonate the client.

   o  The server does not gain the ability to impersonate the client to
      other servers (with an exception for server-authorized proxies),
      unless such other servers allow SCRAM authentication and use the
      same salt and iteration count for the user.

   o  The mechanism is extensible, but [hopefully] not overengineered in
      this respect.

   o  Easier to implement than HTTP Digest in both clients and servers.

12.  References

12.1.  Normative References

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <http://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <http://www.rfc-editor.org/info/rfc3629>.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <http://www.rfc-editor.org/info/rfc4648>.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234,
              DOI 10.17487/RFC5234, January 2008,
              <http://www.rfc-editor.org/info/rfc5234>.








Melnikov                  Expires June 7, 2016                 [Page 16]

Internet-Draft                 HTTP SCRAM                  December 2015


   [RFC5802]  Newman, C., Menon-Sen, A., Melnikov, A., and N. Williams,
              "Salted Challenge Response Authentication Mechanism
              (SCRAM) SASL and GSS-API Mechanisms", RFC 5802,
              DOI 10.17487/RFC5802, July 2010,
              <http://www.rfc-editor.org/info/rfc5802>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <http://www.rfc-editor.org/info/rfc6234>.

   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", RFC 7235,
              DOI 10.17487/RFC7235, June 2014,
              <http://www.rfc-editor.org/info/rfc7235>.

   [RFC7613]  Saint-Andre, P. and A. Melnikov, "Preparation,
              Enforcement, and Comparison of Internationalized Strings
              Representing Usernames and Passwords", RFC 7613,
              DOI 10.17487/RFC7613, August 2015,
              <http://www.rfc-editor.org/info/rfc7613>.

   [RFC7615]  Reschke, J., "HTTP Authentication-Info and Proxy-
              Authentication-Info Response Header Fields", RFC 7615,
              DOI 10.17487/RFC7615, September 2015,
              <http://www.rfc-editor.org/info/rfc7615>.

   [RFC7677]  Hansen, T., "SCRAM-SHA-256 and SCRAM-SHA-256-PLUS Simple
              Authentication and Security Layer (SASL) Mechanisms",
              RFC 7677, DOI 10.17487/RFC7677, November 2015,
              <http://www.rfc-editor.org/info/rfc7677>.

12.2.  Informative References

   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,
              "Remote Authentication Dial In User Service (RADIUS)",
              RFC 2865, DOI 10.17487/RFC2865, June 2000,
              <http://www.rfc-editor.org/info/rfc2865>.

   [RFC2898]  Kaliski, B., "PKCS #5: Password-Based Cryptography
              Specification Version 2.0", RFC 2898,
              DOI 10.17487/RFC2898, September 2000,
              <http://www.rfc-editor.org/info/rfc2898>.

   [RFC2945]  Wu, T., "The SRP Authentication and Key Exchange System",
              RFC 2945, DOI 10.17487/RFC2945, September 2000,
              <http://www.rfc-editor.org/info/rfc2945>.




Melnikov                  Expires June 7, 2016                 [Page 17]

Internet-Draft                 HTTP SCRAM                  December 2015


   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.

   [RFC4510]  Zeilenga, K., Ed., "Lightweight Directory Access Protocol
              (LDAP): Technical Specification Road Map", RFC 4510,
              DOI 10.17487/RFC4510, June 2006,
              <http://www.rfc-editor.org/info/rfc4510>.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2",
              FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,
              <http://www.rfc-editor.org/info/rfc4949>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <http://www.rfc-editor.org/info/rfc5246>.

   [RFC6331]  Melnikov, A., "Moving DIGEST-MD5 to Historic", RFC 6331,
              DOI 10.17487/RFC6331, July 2011,
              <http://www.rfc-editor.org/info/rfc6331>.

Author's Address

   Alexey Melnikov
   Isode Ltd

   Email: Alexey.Melnikov@isode.com






















Melnikov                  Expires June 7, 2016                 [Page 18]
